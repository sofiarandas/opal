/* BSD 2-Clause License - see OPAL/LICENSE for details. */
package org.opalj.tac.tactobc

import org.opalj.RelationalOperators.{EQ, GE, GT, LE, LT, NE}
import org.opalj.br.Method
import org.opalj.br.analyses.Project
import org.opalj.br.instructions.{ATHROW, IFEQ, IFGE, IFGT, IFLE, IFLT, IFNE, INVOKEVIRTUAL, Instruction, NOP, RETURN}
import org.opalj.tac._
import org.opalj.value.ValueInformation

import java.io.File
import scala.collection.mutable.ArrayBuffer

object TACtoBC {

  /**
   * Compiles the Three-Address Code (TAC) representation for all methods in the given .class file.
   *
   * @param file A File object representing the .class file to be analyzed and compiled into TAC.
   * @return A Map associating each method in the class file with its corresponding TAC representation.
   */
  def compileTAC(file: File): Map[Method, AITACode[TACMethodParameter, ValueInformation]] = {
    val p = Project(file)
    val tacProvider = p.get(LazyDetachedTACAIKey)

    // Store the TAC results in a map
    val methodTACMap = scala.collection.mutable.Map.empty[Method, AITACode[TACMethodParameter, ValueInformation]]

    for {
      cf <- p.allProjectClassFiles
      m <- cf.methods
      if m.body.isDefined
    } {
      val tac = tacProvider(m)
      methodTACMap += (m -> tac)
    }

    methodTACMap.toMap
  }

  /**
   * Compiles and prints the bytecode representation for all methods in the given .class file.
   *
   * @param file The .class file or JAR archive to be analyzed.
   * @return A Map associating each method in the class file with its bytecode instructions.
   */
  def compileByteCode(file: File): Map[Method, Array[String]] = {
    val p = Project(file)

    // A map to store the bytecode representation of each method
    val methodByteCodeMap = scala.collection.mutable.Map.empty[Method, Array[String]]

    for {
      cf <- p.allProjectClassFiles
      method <- cf.methods
      if method.body.isDefined
    } {
      // Convert the body's instructions to a human-readable format
      val instructions = method.body.get.instructions.zipWithIndex.map { case (instr, index) =>
        s"$index: ${instr}"
      }
      methodByteCodeMap += (method -> instructions.toArray)

      // Print the bytecode for each method
      println(s"Method: ${method.toJava}")
      instructions.foreach(println)
    }

    methodByteCodeMap.toMap
  }

  /**
   * Translates the TAC representations of methods back to bytecode, encapsulated within OPAL's Code structure.
   *
   * This method iterates over each method's TAC representation and generates a corresponding sequence of
   * bytecode instructions, effectively reversing the process of TAC generation. The resulting bytecode
   * is suitable for execution by the JVM.
   *
   * @param tacs A Map containing the TAC representations of methods to be translated back to bytecode.
   * @return A Map associating each method with its newly generated bytecode, wrapped in OPAL's Code structure.
   */
  def translateTACtoBC(tacs: Map[Method, AITACode[TACMethodParameter, ValueInformation]]): Map[Method, ArrayBuffer[(Int, Instruction)]] = {
    tacs.map { case (method, tacCode) =>
      // Convert the TAC representation back to bytecode for each method
      val bytecodeInstructions = translateSingleTACtoBC(tacCode)
      method -> bytecodeInstructions
    }
  }

  /**
   * Converts the TAC representation of a single method into bytecode instructions.
   *
   * This helper method processes one method's TAC representation at a time, converting it into a sequence
   * of bytecode instructions. It handles various types of TAC statements and expressions, translating them
   * into their equivalent bytecode form.
   *
   * @param tac The TAC representation of a method to be converted into bytecode.
   * @return An array of bytecode instructions representing the method's functionality, ready to be executed by the JVM.
   */
  def translateSingleTACtoBC(tac: AITACode[TACMethodParameter, ValueInformation]): ArrayBuffer[(Int, Instruction)] = {
    val instructionsWithPCs = ArrayBuffer[(Int, Instruction)]()
    var currentPC = 0

    tac.stmts.foreach {
      //Best practice will be to have only 1 case per Stmt
      //loading constants
      case Assignment(_, targetVar, expr) =>
        currentPC = AssignmentUtils.processAssignment(targetVar, expr, instructionsWithPCs, currentPC)
      //Register allocator fÃ¼r variables
      //liste von variablen die existieren
      //map von local variables zu indexes
      //visitor design pattern -> code generation
      //Todo: figure out how BC intructions can be categorized ->
      //figure out if following sentecne is correct: there are only constants and local variables.
      //todo figure out if the tacai is really 1 to 1 to be reverse engineered
      //Todo do tests :D
      case VirtualMethodCall(_, declaringClass, isInterface, name, descriptor, _, _) =>
        if(isInterface) {
          //labeledCode.insert(pc, InsertionPosition.At, Seq(INVOKEINTERFACE(declaringClass, name, descriptor)))
        } else {
          val instruction = INVOKEVIRTUAL(declaringClass, name, descriptor)
          instructionsWithPCs += ((currentPC, instruction))
          currentPC += instruction.length
        }
      case Return(_) =>
        val instruction = RETURN
        instructionsWithPCs += ((currentPC, instruction))
        currentPC += instruction.length
      case Nop(_) =>
        val instruction = NOP
        instructionsWithPCs += ((currentPC, instruction))
        currentPC += instruction.length
      case Throw(_,_) =>
        //ToDo: fix initialization
        val instruction = ATHROW
        instructionsWithPCs += ((currentPC, instruction))
      //currentPC += instruction.length
      case If(_, left, condition, right, gotoLabel) =>
        //helper method write variable in the stack -> load it
        //helper method const or local variable
        //
        // Operators to compare int values.
        //
        if(condition == LT) {
          val instruction = new IFLT(-1)
          instructionsWithPCs += ((currentPC, instruction))
          currentPC += instruction.length
        } else if(condition == GT) {
          val instruction = new IFGT(-1)
          instructionsWithPCs += ((currentPC, instruction))
          currentPC += instruction.length
        } else if(condition == LE) {
          val instruction = new IFLE(-1) // -1 as a placeholder
          instructionsWithPCs += ((currentPC, instruction))
          currentPC += instruction.length
        } else if(condition == GE) {
          val instruction = IFGE(-1)
          instructionsWithPCs += ((currentPC, instruction))
          currentPC += instruction.length
        }
        //
        // Operators to compare int and reference values.
        //
        else if(condition == EQ) {
          val instruction = IFEQ(-1)
          instructionsWithPCs += ((currentPC, instruction))
          currentPC += instruction.length
        } else if(condition == NE) {
          val instruction = IFNE(-1)
          instructionsWithPCs += ((currentPC, instruction))
          currentPC += instruction.length
        }
      //
      // Operators to compare floating point numbers.
      //
      /*else if(condition == CMPG) {
        val instruction = IF_ICMPG(-1)
      }*/
      case _ =>
    }
    instructionsWithPCs
  }

  def main(args: Array[String]): Unit = {
    if (args.length != 1) {
      println("Usage: TACtoBC <path to class or jar file>")
      return
    }

    val file = new File(args(0))
    if (!file.exists()) {
      println(s"File ${file.getPath} does not exist.")
      return
    }

    compileByteCode(file)

    val tacs = compileTAC(file)

    // Print out TAC
    tacs.foreach { case (method, tac) =>
      tac.detach()
      println(s"Method: ${method.toJava}")
      println(tac.toString)
      println("\n")

    }

    // Print out the translation from TAC to Bytecode
    val byteCodes = translateTACtoBC(tacs)
    byteCodes.foreach { case (method, bytecode) =>
      println(s"Method: ${method.toJava}")
      bytecode.foreach(instr => println(instr.toString))
    }

  }
}
